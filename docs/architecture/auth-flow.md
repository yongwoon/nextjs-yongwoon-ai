# 인증 Flow

## 개요

이 문서는 yongwoon.ai 에서 사용하는 **Magic Link 기반 통합 인증 시스템**에 대해 설명합니다.
모든 사용자 인증(회원가입/로그인)은 Magic Link를 통해 이루어지며, 별도의 비밀번호 설정이나 관리가 필요하지 않습니다.

## 통합 인증 Flow (신규/기존 사용자 공통)

### 개요도

```text
[사용자]
   ↓
이메일 입력
   ↓
[SendMagicLink]
   ↓
이메일 수신
   ↓
Magic Link 클릭
   ↓
[VerifyToken]
   ↓
자동 로그인 완료
   ↓
홈페이지
```

### 단계별 Flow

#### 1. Magic Link 요청

- **Frontend Page**: `EmailInputPage` (기존 signup/login 통합)
- **사용자 동작**: 이메일 주소 입력
- **호출되는 RPC**: `SendMagicLink`
- **처리 과정**:
  - 사용자가 이메일 주소를 입력합니다
  - Frontend에서 SendMagicLink RPC를 호출합니다
  - Backend는 이메일이 기존 사용자인지 신규 사용자인지 확인합니다
  - 보안 토큰을 생성하고 magic link가 포함된 이메일을 발송합니다
  - **Magic Link URL**: `http://localhost:5001/mago.user.v1.AuthService/VerifyToken?token={token}`
  - Frontend는 이메일 발송 확인 메시지를 표시합니다

#### 2. Magic Link 인증 및 자동 로그인

- **사용자 동작**: 이메일의 magic link 클릭
- **호출되는 엔드포인트**: `GET http://localhost:5001/mago.user.v1.AuthService/VerifyToken?token={token}`
- **처리 과정**:
  - 사용자가 이메일의 magic link를 클릭합니다
  - Link는 직접 backend의 VerifyToken 엔드포인트로 GET 요청을 보냅니다
  - Backend는 토큰을 검증합니다
  - **신규 사용자인 경우**: 자동으로 계정을 생성합니다
  - **기존 사용자인 경우**: 기존 계정으로 인증합니다
  - Backend는 JWT 토큰을 생성하고 반환합니다
  - 성공 시 frontend로 리디렉션하며 JWT 토큰을 전달합니다
  - 사용자는 자동으로 로그인 상태가 되어 홈페이지로 이동합니다

#### 2-1. 검증 코드를 통한 대체 인증 방법

- **Frontend Page**: `EmailSentPage` → `VerificationPage`
- **사용자 동작**: `VerificationPage`에서 `verification code` 입력
- **호출되는 RPC**: `VerifyVerificationCode`
- **처리 과정**:
  - 사용자가 이메일의 `verification code`를 확인합니다
  - 사용자가 `VerificationPage`에서 `verification code`를 입력합니다
  - Frontend는 `VerifyVerificationCode` RPC를 호출합니다
  - Backend는 code를 검증하고 사용자 계정을 확인/생성합니다
  - Backend는 JWT 토큰을 반환합니다
  - Frontend는 토큰을 저장하고 사용자를 홈페이지로 리디렉션합니다

#### 2-2. 다른 브라우저에서 Magic Link 접근 시 처리

- **시나리오**: 사용자가 Chrome에서 이메일을 입력했지만, Safari나 시크릿 모드에서 Magic Link를 클릭한 경우
- **Frontend Page**: `CrossBrowserVerificationPage`
- **처리 과정**:
  - 사용자가 다른 브라우저/디바이스에서 Magic Link를 클릭합니다
  - Backend는 요청의 User-Agent, IP, 세션 정보를 확인합니다
  - 원래 요청과 다른 브라우저/환경임을 감지합니다
  - Backend는 토큰을 검증하고 6자리 verification code를 생성합니다
  - **CrossBrowserVerificationPage**를 표시합니다:
    ```text
    "다른 브라우저에서 접근하신 것 같습니다"
    "보안을 위해 아래 코드를 복사하여
     원래 로그인을 시도한 브라우저에서 입력해주세요"

    [123456] [코드 복사]

    "원래 브라우저로 돌아가서 코드를 입력하세요"
    ```
  - 사용자는 코드를 복사하고 원래 브라우저로 돌아갑니다
  - 원래 브라우저의 `VerificationPage`에서 코드를 입력합니다
  - Frontend는 `VerifyVerificationCode` RPC를 호출합니다
  - Backend는 코드를 검증하고 JWT 토큰을 반환합니다
  - 원래 브라우저에서 로그인이 완료됩니다

## 세션 관리

### 토큰 갱신

- **호출되는 RPC**: `RefreshToken`
- **처리 과정**:
  - JWT access 토큰이 만료되면 frontend에서 RefreshToken을 호출합니다
  - Backend는 refresh 토큰을 검증하고 새 토큰을 발급합니다

### 로그아웃

- **Frontend Page**: 로그아웃 옵션이 있는 모든 페이지
- **호출되는 RPC**: `Logout`
- **처리 과정**:
  - 사용자가 로그아웃을 클릭합니다
  - Frontend는 Logout RPC를 호출합니다
  - Backend는 토큰을 무효화합니다
  - Frontend는 저장된 토큰을 삭제합니다
  - 사용자는 이메일 입력 페이지로 리디렉션됩니다

## 특수 상황 처리

### 인증 중단 후 재접속

- **시나리오**: 사용자가 Magic Link를 클릭했지만 브라우저를 닫은 경우
- **처리 과정**:
  - 사용자가 애플리케이션에 다시 접속할 때
  - Frontend는 저장소에서 JWT 토큰을 감지합니다
  - Frontend는 세션 검증을 위해 RefreshToken을 호출합니다
  - 토큰이 유효하면 사용자를 홈페이지로 리디렉션합니다
  - 토큰이 무효하면 이메일 입력 페이지로 리디렉션합니다

### Magic Link 만료

- **시나리오**: 사용자가 만료된 Magic Link를 클릭한 경우
- **처리 과정**:
  - Backend는 토큰 만료 오류를 반환합니다
  - Frontend는 오류 메시지와 함께 새로운 Magic Link 요청을 안내합니다
  - 사용자는 이메일 입력 페이지로 리디렉션됩니다

### 크로스 브라우저 보안 검증

- **시나리오**: 다른 브라우저/디바이스에서 Magic Link 접근 시
- **보안 검증 요소**:
  - User-Agent 문자열 비교
  - IP 주소 확인 (동일 네트워크 내 허용)
  - 세션 쿠키 존재 여부
  - 브라우저 fingerprinting (선택적)
- **처리 방식**:
  - 의심스러운 접근으로 판단 시 verification code 방식으로 전환
  - 원래 브라우저에서만 최종 인증 완료 허용
  - 보안 로그 기록 및 모니터링

## 보안 고려사항

### 공통 보안 요소

- JWT 토큰은 안전하게 저장됩니다
- Access 토큰은 제한된 수명을 가집니다
- Magic link는 설정된 기간(15분) 후 만료됩니다
- Magic link는 일회성으로, 사용 후 즉시 무효화됩니다
- 모든 민감한 통신은 HTTPS를 사용합니다
- 모든 인증이 필요한 API 요청은 JWT 토큰 검증을 거쳐야 합니다

### Magic Link 보안

- Magic Link 토큰은 일회성이며 제한된 시간(보통 15분) 동안만 유효합니다
- 토큰은 사용 후 즉시 무효화됩니다
- 동일한 이메일로 새로운 Magic Link 요청 시 기존 토큰은 무효화됩니다
- Magic Link는 충분한 엔트로피를 가진 암호학적으로 안전한 토큰을 사용합니다

### 계정 보안

- 이메일 주소가 계정의 유일한 식별자입니다
- 이메일 접근 권한이 있는 사용자만 계정에 접근할 수 있습니다
- 의심스러운 로그인 시도는 로그로 기록됩니다
- 과도한 Magic Link 요청은 제한됩니다 (Rate Limiting)

### 크로스 브라우저 보안

- 다른 브라우저에서의 Magic Link 접근을 자동으로 감지합니다
- Verification code는 6자리 숫자로 구성되며 5분간 유효합니다
- 원래 브라우저에서만 최종 인증을 완료할 수 있습니다
- 크로스 브라우저 접근 시도는 보안 로그에 기록됩니다
- 동일한 토큰으로 여러 번의 크로스 브라우저 접근 시도 시 토큰을 무효화합니다

## 토큰 시스템 설명

### 토큰의 종류와 차이점

#### 1. Magic Link 토큰

- **용도**: 이메일을 통한 일회성 인증에 사용됩니다
- **저장위치**: 데이터베이스의 `auth_tokens` 테이블에 저장됩니다
- **생명주기**: 일정 시간(15분) 후 만료되며, 사용 시 즉시 무효화됩니다
- **특징**: 이메일 링크 또는 인증 코드 형태로 사용자에게 전달됩니다

#### 2. JWT 토큰 (JSON Web Token)

- **용도**: 사용자 인증 상태를 유지하고 API 접근 권한을 부여합니다
- **저장위치**: 클라이언트 측(브라우저)에 저장되며, 데이터베이스에는 저장되지 않습니다
- **생명주기**: 설정된 기간(기본 24시간) 동안 유효하며, 갱신 가능합니다
- **특징**: 사용자 정보와 권한을 포함하는 자체 검증 가능한 토큰입니다

#### 3. Verification Code

- **용도**: 크로스 브라우저 상황에서 원래 브라우저로 인증을 전달하는 데 사용됩니다
- **저장위치**: 데이터베이스에 임시 저장되며 Magic Link 토큰과 연결됩니다
- **생명주기**: 5분간 유효하며, 사용 후 즉시 무효화됩니다
- **특징**: 6자리 숫자로 구성되며, 사용자가 수동으로 입력합니다

### JWT 토큰 검증 프로세스

모든 인증이 필요한 API 요청에서는 클라이언트가 제공한 JWT 토큰을 다음과 같이 검증합니다:

1. **토큰 검증 과정**:
   - 클라이언트가 Authorization 헤더에 JWT 토큰을 포함하여 요청을 보냅니다
   - 서버는 토큰의 서명을 검증하여 변조되지 않았는지 확인합니다
   - 토큰의 만료 시간을 검사하여 유효한지 확인합니다
   - 토큰에 포함된 사용자 정보를 추출하여 요청 처리에 활용합니다

2. **API 엔드포인트별 권한 검증**:
   - JWT 토큰에는 사용자 역할 정보(`role`)가 포함되어 있습니다
   - 각 API 엔드포인트는 필요한 최소 권한 수준을 지정할 수 있습니다
   - 서버는 요청한 사용자의 역할이 해당 작업에 충분한지 검증합니다

3. **토큰 갱신 및 보안**:
   - 만료된 토큰은 Refresh 토큰을 통해 갱신할 수 있습니다
   - JWT 토큰은 서버의 비밀 키로 서명되어 위조를 방지합니다
   - 민감한 정보는 토큰에 직접 포함하지 않도록 합니다

## 사용자 경험 (UX) 고려사항

### 간소화된 인증 과정

- 사용자는 비밀번호를 기억하거나 관리할 필요가 없습니다
- 회원가입과 로그인이 동일한 과정으로 통합되어 혼란을 줄입니다
- 이메일만으로 간단하게 계정에 접근할 수 있습니다

### 사용자 안내

- 이메일 입력 페이지에서 "Sign up" 또는 "Sign in" 구분 없이 "Continue with email" 등의 통합된 메시지 사용
- Magic Link 이메일 발송 후 명확한 안내 메시지 제공
- Magic Link 만료 시 친화적인 오류 메시지와 재요청 옵션 제공

### 접근성

- 이메일에 접근할 수 없는 상황을 대비한 대체 인증 방법(verification code) 제공
- 명확하고 이해하기 쉬운 UI/UX 디자인
- 모바일 환경에서도 원활한 Magic Link 처리

### 크로스 브라우저 사용성

- 다른 브라우저에서 Magic Link를 열었을 때 명확한 안내 제공
- 코드 복사 기능으로 사용자 편의성 향상
- 원래 브라우저로 돌아가는 과정을 직관적으로 안내
- 모바일과 데스크톱 간 전환 시에도 원활한 사용자 경험 제공
